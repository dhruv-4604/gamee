<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cheerful Biscuit Stacker</title>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #FF4500;
            font-family: 'Arial', sans-serif;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #backgroundImage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            object-fit: cover;
        }
    </style>
</head>
<body>
    <img id="backgroundImage" src="assets/background.jpg" alt="Background">
    <div id="info">Score: <span id="score">0</span> | Time: <span id="time">120</span></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
        let scene, camera, renderer, plate, score = 0, timeLeft = 120;
        let fallingObjects = [];
        const plateStack = [];
        let screenWidth, screenHeight;

        function init() {
            scene = new THREE.Scene();
            updateScreenDimensions();
            camera = new THREE.PerspectiveCamera(75, screenWidth / screenHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(screenWidth, screenHeight);
            renderer.setClearColor(0x000000, 0);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xFFFFA0, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            plate = createPlate();
            scene.add(plate);

            camera.position.z = 5;

            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('touchmove', onPointerMove);
            document.addEventListener('touchstart', onPointerMove);

            setInterval(createFallingObject, 1000);
            setInterval(updateTimer, 1000);

            window.addEventListener('resize', onWindowResize, false);
        }

        function updateScreenDimensions() {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
        }

        function createPlate() {
            const geometry = new THREE.CylinderGeometry(0.8, 0.8, 0.1, 32);
            const material = new THREE.MeshPhongMaterial({ color: 0xFFA500, shininess: 100 });
            const plate = new THREE.Mesh(geometry, material);
            plate.position.y = -2;
            return plate;
        }

        function createFallingObject() {
            const types = ['base', 'cream', 'top'];
            const type = types[Math.floor(Math.random() * types.length)];
            let object;

            switch(type) {
                case 'base':
                    object = createBase();
                    break;
                case 'cream':
                    object = createCream();
                    break;
                case 'top':
                    object = createTop();
                    break;
            }

            object.userData.type = type;
            const maxX = 2.5; // Adjust this value to control the spawn width
            object.position.set((Math.random() - 0.5) * maxX * 2, 3, 0);
            fallingObjects.push(object);
            scene.add(object);
        }

        function createBase() {
            const geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);
            const material = new THREE.MeshPhongMaterial({ color: 0xD2691E, shininess: 30 });
            return new THREE.Mesh(geometry, material);
        }

        function createCream() {
            const geometry = new THREE.CylinderGeometry(0.35, 0.35, 0.1, 32);
            const material = new THREE.MeshPhongMaterial({ color: 0xFFFACD, shininess: 50 });
            return new THREE.Mesh(geometry, material);
        }

        function createTop() {
            const group = new THREE.Group();

            const topGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 32);
            const topMaterial = new THREE.MeshPhongMaterial({ color: 0xD2691E, shininess: 30 });
            const topMesh = new THREE.Mesh(topGeometry, topMaterial);
            group.add(topMesh);

            const jamGeometry = new THREE.SphereGeometry(0.1, 32, 32);
            const jamMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000, shininess: 80 });
            const jam = new THREE.Mesh(jamGeometry, jamMaterial);
            jam.position.y = 0.05;
            group.add(jam);

            return group;
        }

        function onPointerMove(event) {
            event.preventDefault();
            let clientX;

            if (event.type === 'touchmove' || event.type === 'touchstart') {
                clientX = event.touches[0].clientX;
            } else {
                clientX = event.clientX;
            }

            const x = (clientX / screenWidth) * 2 - 1;
            const maxX = 2.5; // Adjust this value to match the spawn width
            plate.position.x = THREE.MathUtils.clamp(x * 3, -maxX, maxX);

            plateStack.forEach(obj => {
                obj.position.x = plate.position.x;
            });
        }

        function updateTimer() {
            timeLeft--;
            document.getElementById('time').textContent = timeLeft;
            if (timeLeft <= 0) {
                alert(`Game Over! Your score: ${score}`);
                location.reload();
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);

            fallingObjects.forEach((obj, index) => {
                obj.position.y -= 0.05;
                obj.rotation.y += 0.02;

                if (obj.position.y < -2 && Math.abs(obj.position.x - plate.position.x) < 0.5) {
                    scene.remove(obj);
                    fallingObjects.splice(index, 1);

                    if (checkStack(obj.userData.type)) {
                        plateStack.push(obj);
                        obj.position.y = -1.9 + (plateStack.length - 1) * 0.1;
                        obj.position.x = plate.position.x;
                        scene.add(obj);

                        new TWEEN.Tween(obj.position)
                            .to({ y: obj.position.y + 0.1 }, 100)
                            .easing(TWEEN.Easing.Bounce.Out)
                            .start();

                        if (plateStack.length === 3) {
                            score++;
                            document.getElementById('score').textContent = score;
                            
                            plateStack.forEach((stackObj, i) => {
                                new TWEEN.Tween(stackObj.position)
                                    .to({ y: stackObj.position.y + 1 }, 500)
                                    .easing(TWEEN.Easing.Cubic.Out)
                                    .onComplete(() => {
                                        scene.remove(stackObj);
                                        if (i === plateStack.length - 1) {
                                            plateStack.length = 0;
                                        }
                                    })
                                    .start();

                                new TWEEN.Tween(stackObj.rotation)
                                    .to({ y: Math.PI * 2 }, 500)
                                    .start();
                            });
                        }
                    } else {
                        plateStack.forEach(stackObj => {
                            new TWEEN.Tween(stackObj.position)
                                .to({ y: -5 }, 1000)
                                .easing(TWEEN.Easing.Bounce.Out)
                                .onComplete(() => scene.remove(stackObj))
                                .start();

                            new TWEEN.Tween(stackObj.rotation)
                                .to({ x: Math.random() * Math.PI * 2, z: Math.random() * Math.PI * 2 }, 1000)
                                .start();
                        });
                        plateStack.length = 0;
                    }
                } else if (obj.position.y < -3) {
                    scene.remove(obj);
                    fallingObjects.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }

        function checkStack(type) {
            if (plateStack.length === 0 && type === 'base') return true;
            if (plateStack.length === 1 && plateStack[0].userData.type === 'base' && type === 'cream') return true;
            if (plateStack.length === 2 && plateStack[0].userData.type === 'base' && plateStack[1].userData.type === 'cream' && type === 'top') return true;
            return false;
        }

        function onWindowResize() {
            updateScreenDimensions();
            camera.aspect = screenWidth / screenHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(screenWidth, screenHeight);
        }

        init();
        animate();
    </script>
</body>
</html>